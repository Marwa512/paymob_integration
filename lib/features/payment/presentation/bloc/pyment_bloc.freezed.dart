// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'pyment_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PaymentState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentStateCopyWith<$Res> {
  factory $PaymentStateCopyWith(
          PaymentState value, $Res Function(PaymentState) then) =
      _$PaymentStateCopyWithImpl<$Res, PaymentState>;
}

/// @nodoc
class _$PaymentStateCopyWithImpl<$Res, $Val extends PaymentState>
    implements $PaymentStateCopyWith<$Res> {
  _$PaymentStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl with DiagnosticableTreeMixin implements Initial {
  const _$InitialImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentState.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PaymentState.initial'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements PaymentState {
  const factory Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadInProgressImplCopyWith<$Res> {
  factory _$$LoadInProgressImplCopyWith(_$LoadInProgressImpl value,
          $Res Function(_$LoadInProgressImpl) then) =
      __$$LoadInProgressImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadInProgressImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$LoadInProgressImpl>
    implements _$$LoadInProgressImplCopyWith<$Res> {
  __$$LoadInProgressImplCopyWithImpl(
      _$LoadInProgressImpl _value, $Res Function(_$LoadInProgressImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadInProgressImpl
    with DiagnosticableTreeMixin
    implements LoadInProgress {
  const _$LoadInProgressImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentState.loadInProgress()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PaymentState.loadInProgress'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadInProgressImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) {
    return loadInProgress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) {
    return loadInProgress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) {
    if (loadInProgress != null) {
      return loadInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) {
    return loadInProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) {
    return loadInProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) {
    if (loadInProgress != null) {
      return loadInProgress(this);
    }
    return orElse();
  }
}

abstract class LoadInProgress implements PaymentState {
  const factory LoadInProgress() = _$LoadInProgressImpl;
}

/// @nodoc
abstract class _$$SelectPaymentTypeSuccessImplCopyWith<$Res> {
  factory _$$SelectPaymentTypeSuccessImplCopyWith(
          _$SelectPaymentTypeSuccessImpl value,
          $Res Function(_$SelectPaymentTypeSuccessImpl) then) =
      __$$SelectPaymentTypeSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectPaymentTypeSuccessImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$SelectPaymentTypeSuccessImpl>
    implements _$$SelectPaymentTypeSuccessImplCopyWith<$Res> {
  __$$SelectPaymentTypeSuccessImplCopyWithImpl(
      _$SelectPaymentTypeSuccessImpl _value,
      $Res Function(_$SelectPaymentTypeSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectPaymentTypeSuccessImpl
    with DiagnosticableTreeMixin
    implements SelectPaymentTypeSuccess {
  const _$SelectPaymentTypeSuccessImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentState.selectPaymentTypeSuccess()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(
        DiagnosticsProperty('type', 'PaymentState.selectPaymentTypeSuccess'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectPaymentTypeSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) {
    return selectPaymentTypeSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) {
    return selectPaymentTypeSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) {
    if (selectPaymentTypeSuccess != null) {
      return selectPaymentTypeSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) {
    return selectPaymentTypeSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) {
    return selectPaymentTypeSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) {
    if (selectPaymentTypeSuccess != null) {
      return selectPaymentTypeSuccess(this);
    }
    return orElse();
  }
}

abstract class SelectPaymentTypeSuccess implements PaymentState {
  const factory SelectPaymentTypeSuccess() = _$SelectPaymentTypeSuccessImpl;
}

/// @nodoc
abstract class _$$PaymentSuccessImplCopyWith<$Res> {
  factory _$$PaymentSuccessImplCopyWith(_$PaymentSuccessImpl value,
          $Res Function(_$PaymentSuccessImpl) then) =
      __$$PaymentSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String url});
}

/// @nodoc
class __$$PaymentSuccessImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$PaymentSuccessImpl>
    implements _$$PaymentSuccessImplCopyWith<$Res> {
  __$$PaymentSuccessImplCopyWithImpl(
      _$PaymentSuccessImpl _value, $Res Function(_$PaymentSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
  }) {
    return _then(_$PaymentSuccessImpl(
      null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentSuccessImpl
    with DiagnosticableTreeMixin
    implements PaymentSuccess {
  const _$PaymentSuccessImpl(this.url);

  @override
  final String url;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentState.paymentSuccess(url: $url)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PaymentState.paymentSuccess'))
      ..add(DiagnosticsProperty('url', url));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentSuccessImpl &&
            (identical(other.url, url) || other.url == url));
  }

  @override
  int get hashCode => Object.hash(runtimeType, url);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentSuccessImplCopyWith<_$PaymentSuccessImpl> get copyWith =>
      __$$PaymentSuccessImplCopyWithImpl<_$PaymentSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) {
    return paymentSuccess(url);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) {
    return paymentSuccess?.call(url);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) {
    if (paymentSuccess != null) {
      return paymentSuccess(url);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) {
    return paymentSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) {
    return paymentSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) {
    if (paymentSuccess != null) {
      return paymentSuccess(this);
    }
    return orElse();
  }
}

abstract class PaymentSuccess implements PaymentState {
  const factory PaymentSuccess(final String url) = _$PaymentSuccessImpl;

  String get url;

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PaymentSuccessImplCopyWith<_$PaymentSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentFailedImplCopyWith<$Res> {
  factory _$$PaymentFailedImplCopyWith(
          _$PaymentFailedImpl value, $Res Function(_$PaymentFailedImpl) then) =
      __$$PaymentFailedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentFailedImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$PaymentFailedImpl>
    implements _$$PaymentFailedImplCopyWith<$Res> {
  __$$PaymentFailedImplCopyWithImpl(
      _$PaymentFailedImpl _value, $Res Function(_$PaymentFailedImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PaymentFailedImpl
    with DiagnosticableTreeMixin
    implements PaymentFailed {
  const _$PaymentFailedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentState.paymentFailed()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PaymentState.paymentFailed'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentFailedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) {
    return paymentFailed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) {
    return paymentFailed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) {
    return paymentFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) {
    return paymentFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) {
    if (paymentFailed != null) {
      return paymentFailed(this);
    }
    return orElse();
  }
}

abstract class PaymentFailed implements PaymentState {
  const factory PaymentFailed() = _$PaymentFailedImpl;
}

/// @nodoc
abstract class _$$AddCardSuccessImplCopyWith<$Res> {
  factory _$$AddCardSuccessImplCopyWith(_$AddCardSuccessImpl value,
          $Res Function(_$AddCardSuccessImpl) then) =
      __$$AddCardSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddCardSuccessImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$AddCardSuccessImpl>
    implements _$$AddCardSuccessImplCopyWith<$Res> {
  __$$AddCardSuccessImplCopyWithImpl(
      _$AddCardSuccessImpl _value, $Res Function(_$AddCardSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddCardSuccessImpl
    with DiagnosticableTreeMixin
    implements AddCardSuccess {
  const _$AddCardSuccessImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentState.addCardSuccess()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PaymentState.addCardSuccess'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AddCardSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loadInProgress,
    required TResult Function() selectPaymentTypeSuccess,
    required TResult Function(String url) paymentSuccess,
    required TResult Function() paymentFailed,
    required TResult Function() addCardSuccess,
  }) {
    return addCardSuccess();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loadInProgress,
    TResult? Function()? selectPaymentTypeSuccess,
    TResult? Function(String url)? paymentSuccess,
    TResult? Function()? paymentFailed,
    TResult? Function()? addCardSuccess,
  }) {
    return addCardSuccess?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loadInProgress,
    TResult Function()? selectPaymentTypeSuccess,
    TResult Function(String url)? paymentSuccess,
    TResult Function()? paymentFailed,
    TResult Function()? addCardSuccess,
    required TResult orElse(),
  }) {
    if (addCardSuccess != null) {
      return addCardSuccess();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(LoadInProgress value) loadInProgress,
    required TResult Function(SelectPaymentTypeSuccess value)
        selectPaymentTypeSuccess,
    required TResult Function(PaymentSuccess value) paymentSuccess,
    required TResult Function(PaymentFailed value) paymentFailed,
    required TResult Function(AddCardSuccess value) addCardSuccess,
  }) {
    return addCardSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(LoadInProgress value)? loadInProgress,
    TResult? Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult? Function(PaymentSuccess value)? paymentSuccess,
    TResult? Function(PaymentFailed value)? paymentFailed,
    TResult? Function(AddCardSuccess value)? addCardSuccess,
  }) {
    return addCardSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(LoadInProgress value)? loadInProgress,
    TResult Function(SelectPaymentTypeSuccess value)? selectPaymentTypeSuccess,
    TResult Function(PaymentSuccess value)? paymentSuccess,
    TResult Function(PaymentFailed value)? paymentFailed,
    TResult Function(AddCardSuccess value)? addCardSuccess,
    required TResult orElse(),
  }) {
    if (addCardSuccess != null) {
      return addCardSuccess(this);
    }
    return orElse();
  }
}

abstract class AddCardSuccess implements PaymentState {
  const factory AddCardSuccess() = _$AddCardSuccessImpl;
}

/// @nodoc
mixin _$PaymentEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() payment,
    required TResult Function(int index, int? cardIndex) selectPaymentType,
    required TResult Function(CardModel card) addCard,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? payment,
    TResult? Function(int index, int? cardIndex)? selectPaymentType,
    TResult? Function(CardModel card)? addCard,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? payment,
    TResult Function(int index, int? cardIndex)? selectPaymentType,
    TResult Function(CardModel card)? addCard,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Payment value) payment,
    required TResult Function(_SelectPaymentType value) selectPaymentType,
    required TResult Function(_AddCard value) addCard,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Payment value)? payment,
    TResult? Function(_SelectPaymentType value)? selectPaymentType,
    TResult? Function(_AddCard value)? addCard,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Payment value)? payment,
    TResult Function(_SelectPaymentType value)? selectPaymentType,
    TResult Function(_AddCard value)? addCard,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentEventCopyWith<$Res> {
  factory $PaymentEventCopyWith(
          PaymentEvent value, $Res Function(PaymentEvent) then) =
      _$PaymentEventCopyWithImpl<$Res, PaymentEvent>;
}

/// @nodoc
class _$PaymentEventCopyWithImpl<$Res, $Val extends PaymentEvent>
    implements $PaymentEventCopyWith<$Res> {
  _$PaymentEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PaymentImplCopyWith<$Res> {
  factory _$$PaymentImplCopyWith(
          _$PaymentImpl value, $Res Function(_$PaymentImpl) then) =
      __$$PaymentImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentImplCopyWithImpl<$Res>
    extends _$PaymentEventCopyWithImpl<$Res, _$PaymentImpl>
    implements _$$PaymentImplCopyWith<$Res> {
  __$$PaymentImplCopyWithImpl(
      _$PaymentImpl _value, $Res Function(_$PaymentImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PaymentImpl with DiagnosticableTreeMixin implements _Payment {
  const _$PaymentImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentEvent.payment()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'PaymentEvent.payment'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() payment,
    required TResult Function(int index, int? cardIndex) selectPaymentType,
    required TResult Function(CardModel card) addCard,
  }) {
    return payment();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? payment,
    TResult? Function(int index, int? cardIndex)? selectPaymentType,
    TResult? Function(CardModel card)? addCard,
  }) {
    return payment?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? payment,
    TResult Function(int index, int? cardIndex)? selectPaymentType,
    TResult Function(CardModel card)? addCard,
    required TResult orElse(),
  }) {
    if (payment != null) {
      return payment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Payment value) payment,
    required TResult Function(_SelectPaymentType value) selectPaymentType,
    required TResult Function(_AddCard value) addCard,
  }) {
    return payment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Payment value)? payment,
    TResult? Function(_SelectPaymentType value)? selectPaymentType,
    TResult? Function(_AddCard value)? addCard,
  }) {
    return payment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Payment value)? payment,
    TResult Function(_SelectPaymentType value)? selectPaymentType,
    TResult Function(_AddCard value)? addCard,
    required TResult orElse(),
  }) {
    if (payment != null) {
      return payment(this);
    }
    return orElse();
  }
}

abstract class _Payment implements PaymentEvent {
  const factory _Payment() = _$PaymentImpl;
}

/// @nodoc
abstract class _$$SelectPaymentTypeImplCopyWith<$Res> {
  factory _$$SelectPaymentTypeImplCopyWith(_$SelectPaymentTypeImpl value,
          $Res Function(_$SelectPaymentTypeImpl) then) =
      __$$SelectPaymentTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index, int? cardIndex});
}

/// @nodoc
class __$$SelectPaymentTypeImplCopyWithImpl<$Res>
    extends _$PaymentEventCopyWithImpl<$Res, _$SelectPaymentTypeImpl>
    implements _$$SelectPaymentTypeImplCopyWith<$Res> {
  __$$SelectPaymentTypeImplCopyWithImpl(_$SelectPaymentTypeImpl _value,
      $Res Function(_$SelectPaymentTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? cardIndex = freezed,
  }) {
    return _then(_$SelectPaymentTypeImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      cardIndex: freezed == cardIndex
          ? _value.cardIndex
          : cardIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$SelectPaymentTypeImpl
    with DiagnosticableTreeMixin
    implements _SelectPaymentType {
  const _$SelectPaymentTypeImpl(this.index, {this.cardIndex});

  @override
  final int index;
  @override
  final int? cardIndex;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentEvent.selectPaymentType(index: $index, cardIndex: $cardIndex)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PaymentEvent.selectPaymentType'))
      ..add(DiagnosticsProperty('index', index))
      ..add(DiagnosticsProperty('cardIndex', cardIndex));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectPaymentTypeImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.cardIndex, cardIndex) ||
                other.cardIndex == cardIndex));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index, cardIndex);

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectPaymentTypeImplCopyWith<_$SelectPaymentTypeImpl> get copyWith =>
      __$$SelectPaymentTypeImplCopyWithImpl<_$SelectPaymentTypeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() payment,
    required TResult Function(int index, int? cardIndex) selectPaymentType,
    required TResult Function(CardModel card) addCard,
  }) {
    return selectPaymentType(index, cardIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? payment,
    TResult? Function(int index, int? cardIndex)? selectPaymentType,
    TResult? Function(CardModel card)? addCard,
  }) {
    return selectPaymentType?.call(index, cardIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? payment,
    TResult Function(int index, int? cardIndex)? selectPaymentType,
    TResult Function(CardModel card)? addCard,
    required TResult orElse(),
  }) {
    if (selectPaymentType != null) {
      return selectPaymentType(index, cardIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Payment value) payment,
    required TResult Function(_SelectPaymentType value) selectPaymentType,
    required TResult Function(_AddCard value) addCard,
  }) {
    return selectPaymentType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Payment value)? payment,
    TResult? Function(_SelectPaymentType value)? selectPaymentType,
    TResult? Function(_AddCard value)? addCard,
  }) {
    return selectPaymentType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Payment value)? payment,
    TResult Function(_SelectPaymentType value)? selectPaymentType,
    TResult Function(_AddCard value)? addCard,
    required TResult orElse(),
  }) {
    if (selectPaymentType != null) {
      return selectPaymentType(this);
    }
    return orElse();
  }
}

abstract class _SelectPaymentType implements PaymentEvent {
  const factory _SelectPaymentType(final int index, {final int? cardIndex}) =
      _$SelectPaymentTypeImpl;

  int get index;
  int? get cardIndex;

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SelectPaymentTypeImplCopyWith<_$SelectPaymentTypeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddCardImplCopyWith<$Res> {
  factory _$$AddCardImplCopyWith(
          _$AddCardImpl value, $Res Function(_$AddCardImpl) then) =
      __$$AddCardImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CardModel card});
}

/// @nodoc
class __$$AddCardImplCopyWithImpl<$Res>
    extends _$PaymentEventCopyWithImpl<$Res, _$AddCardImpl>
    implements _$$AddCardImplCopyWith<$Res> {
  __$$AddCardImplCopyWithImpl(
      _$AddCardImpl _value, $Res Function(_$AddCardImpl) _then)
      : super(_value, _then);

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? card = null,
  }) {
    return _then(_$AddCardImpl(
      null == card
          ? _value.card
          : card // ignore: cast_nullable_to_non_nullable
              as CardModel,
    ));
  }
}

/// @nodoc

class _$AddCardImpl with DiagnosticableTreeMixin implements _AddCard {
  const _$AddCardImpl(this.card);

  @override
  final CardModel card;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PaymentEvent.addCard(card: $card)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PaymentEvent.addCard'))
      ..add(DiagnosticsProperty('card', card));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddCardImpl &&
            (identical(other.card, card) || other.card == card));
  }

  @override
  int get hashCode => Object.hash(runtimeType, card);

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddCardImplCopyWith<_$AddCardImpl> get copyWith =>
      __$$AddCardImplCopyWithImpl<_$AddCardImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() payment,
    required TResult Function(int index, int? cardIndex) selectPaymentType,
    required TResult Function(CardModel card) addCard,
  }) {
    return addCard(card);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? payment,
    TResult? Function(int index, int? cardIndex)? selectPaymentType,
    TResult? Function(CardModel card)? addCard,
  }) {
    return addCard?.call(card);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? payment,
    TResult Function(int index, int? cardIndex)? selectPaymentType,
    TResult Function(CardModel card)? addCard,
    required TResult orElse(),
  }) {
    if (addCard != null) {
      return addCard(card);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Payment value) payment,
    required TResult Function(_SelectPaymentType value) selectPaymentType,
    required TResult Function(_AddCard value) addCard,
  }) {
    return addCard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Payment value)? payment,
    TResult? Function(_SelectPaymentType value)? selectPaymentType,
    TResult? Function(_AddCard value)? addCard,
  }) {
    return addCard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Payment value)? payment,
    TResult Function(_SelectPaymentType value)? selectPaymentType,
    TResult Function(_AddCard value)? addCard,
    required TResult orElse(),
  }) {
    if (addCard != null) {
      return addCard(this);
    }
    return orElse();
  }
}

abstract class _AddCard implements PaymentEvent {
  const factory _AddCard(final CardModel card) = _$AddCardImpl;

  CardModel get card;

  /// Create a copy of PaymentEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddCardImplCopyWith<_$AddCardImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
